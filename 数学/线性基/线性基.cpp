线性基的性质：
1、线性基的元素能相互异或得到原集合的元素的所有相互异或得到的值
2、线性基是满足性质 1 的最小的集合
3、线性基没有异或和为 0 的子集。
4、线性基中每个元素的异或方案唯一，也就是说，线性基中不同的异或组合异或出的数都是不一样的。
5、线性基中每个元素的二进制最高位互不相同。

构造方法：
对原集合的每个数p转为二进制，从高位向低位扫，对于第x位是1的，如果ax不存在，那么令ax = p并结束扫描，
如果存在，令p = p xor ax 。

inline void insert(long long x) {
  for (int i = 55; i >= 1; i--) {
    if (!(x >> i))  // x的第i位是0
      continue;
    if (!p[i]) {
      p[i] = x;
      break;
    }
    x ^= p[i];
  }
}

求异或和最大值。
    首先构造出这个序列的线性基，然后从线性基的最高位开始，假如当前的答案异或线性基的这个元
素可以变得更大，那么就异或它，答案的初值为0。

ll MAXN() {
    ll ans = 0;
    for(int i = 50; i >= 0; --i) {
        if(ans ^ p[i] > ans) ans ^= p[i];
    }
    return ans;
}

求异或和最小值
    就是线性基的最小值

从一个序列中取任意个元素进行异或，求能异或出的所有数字中第k小的那个。
    首先，对这个线性基处理一下， 对于每一个的p[i], 枚举 j = i to 1, 如果p[i](2) 的
第j位为1， 那么p[i]异或p[j-1].
再将k转成二进制， 假如k的第i位为1， ans就异或上线性基中的第i个元素

void work()//处理线性基
{
	for(int i=1;i<=60;i++)
	for(int j=1;j<=i;j++)
	if(d[i]&(1<<(j-1)))d[i]^=d[j-1];
}
ll k_th(ll k)
{
	if(k==1&&tot<n)return 0;//特判一下，假如k=1，并且原来的序列可以异或出0，就要返回0，tot表示线性基中的元素个数，n表示序列长度
	if(tot<n)k--;//类似上面，去掉0的情况，因为线性基中只能异或出不为0的解
	work();
	ll ans=0;
	for(int i=0;i<=60;i++)
	if(d[i]!=0)
	{
		if(k%2==1)ans^=d[i];
		k/=2;
	}
}
